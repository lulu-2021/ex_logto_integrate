
CLIENT functions under development

import SsoTest.Oidcc.RequestUtils
@storage_key_sign_in_session "StorageKeySignInSession"


  def handle_sign_in_callback(request, logto_client) do
    #sign_in_session =
    #  logto_client.storage.get_item(@storage_key_sign_in_session)
    #  |> Poison.decode!(as: %{})
    sign_in_session = %{}

    callback_uri = get_origin_request_url(request)

    IO.inspect callback_uri, label: "callback_uri"

    #
    # (1) - so in essence this gets the full returned url - and ensures we have the right code
    # (2) - then we get the config details to get token endpoint
    # (3) - then we need the code_verifier - retrieve it from the session
    # (4) - the client_secret (this should not change)
    # (5) - the redirect_uri (this should not change)

    # => this gives us the "code_token_response" ([access_token, scope & expire_in])

    #
    # finally we verify and save this.. where ?
    #

    with {:ok, code} <- #(1)
           Core.verify_and_parse_code_from_callback_uri(
             callback_uri,
             sign_in_session.redirect_uri,
             sign_in_session.state
           ),
         {:ok, oidc_config} <- fetch_oidc_config(logto_client), # (2)
         {:ok, code_token_response} <-
           Core.fetch_token_by_authorization_code(logto_client.http_client, %{
             token_endpoint: oidc_config.token_endpoint,
             code: code,
             code_verifier: sign_in_session.code_verifier, #(3) - we need the code_verifier from the session - this was used to generate the code
             client_id: logto_client.logto_config.app_id,
             client_secret: logto_client.logto_config.app_secret,
             redirect_uri: sign_in_session.redirect_uri
           }),
         :ok <- logto_client.storage.set_item(@storage_key_sign_in_session, "") do
      #access_token = %AccessToken{
      access_token = %{
        token: code_token_response.access_token,
        scope: code_token_response.scope,
        expires_at: :os.system_time(:seconds) + code_token_response.expire_in
      }

      access_token_key = build_access_token_key([], "", "")

      verify_and_save_token_response(
        logto_client,
        code_token_response.id_token,
        code_token_response.refresh_token,
        access_token_key,
        access_token,
        oidc_config
      )
    else
      error -> error
    end
  end

  defp fetch_oidc_config(logto_client) do
    # Implement the logic to fetch the OIDC configuration
    # ...
  end

  defp build_access_token_key(scopes, user_id, client_id) do
    # Implement the logic to build the access token key
    # ...
  end

  defp verify_and_save_token_response(
         logto_client,
         id_token,
         refresh_token,
         access_token_key,
         access_token,
         oidc_config
       ) do
    # Implement the logic to verify and save the token response
    # ...
  end

CORE functions under development

@reserved_resource_organization "ReservedResourceOrganization"

def verify_and_parse_code_from_callback_uri(callback_uri, redirect_uri, state) do

  IO.puts "\n\n verifying code from callback_uri"
  IO.inspect callback_uri
  IO.inspect redirect_uri
  IO.inspect state
  IO.puts "\n\n end \n\n"

  with true <- String.starts_with?(callback_uri, redirect_uri),
       {:ok, parsed_url} <- URI.parse(callback_uri) |> handle_url_parse_error(),
       "" <- parsed_url.query |> URI.decode_query() |> Map.get("error"),
       state_in_uri <- parsed_url.query |> URI.decode_query() |> Map.get("state"),
       state_in_uri == state,
       code <- parsed_url.query |> URI.decode_query() |> Map.get("code"),
       "" != code do
    {:ok, code}
  else
    false ->
      {:error, :callback_uri_not_match_redirect_uri}

    {:error, reason} ->
      {:error, reason}

    "" ->
      {:error, :code_not_found_in_callback_uri}

    _state_in_uri ->
      {:error, :state_not_match}
  end
end

defp handle_url_parse_error(parsed_url), do: {:ok, parsed_url}
